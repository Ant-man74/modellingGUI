classdef LOLAHelper
    %LOLAHELPER Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
    end
    
    methods (Static = true)
        function seq = SetupLOLA(samplesWrapper,does)
            if length(samplesWrapper) < 1
                error('Must have some samples');
            end
            if ~isa(samplesWrapper{1},'Sample')
                error('samplesWrapper must contain type Sample');
            end
            if ~isa(does,'DesignOfExperimentSettings')
                error('does needs to be a DesignOfExperiemtnSettings type');
            end
           % define problem
            problem = struct;
            problem.inputs.nInputs = length(samplesWrapper{1}.HyperParameters);
            problem.inputs.minima = does.LowerBound;
            problem.inputs.maxima = does.LowerBound;
            problem.outputs.nOutputs = 1;

            % create sequential design
            seq = SequentialDesign(problem, 'lola-voronoi.xml');

%             % get initial design and evaluate them
%             newPoints = seq.getInitialDesign();
% 
%             % get the output of the initial design (simulation)
%             out = peaks(newPoints(:,1), newPoints(:,2));
            newPoints = zeros(length(samplesWrapper),length(samplesWrapper{1}.HyperParameters));
            out = zeros(length(samplesWrapper),1);
            for i=1:length(samplesWrapper)
                newPoints(i,:) = samplesWrapper{i}.HyperParameters;
                out(i) = samplesWrapper{i}.Value;
            end

            % return the outputs to the sequential design for processing
            seq = seq.updatePoints(newPoints, out);
            
            % plot the entire design
%             seq.plot();

            % generate some additional points
            for i = 1 : 48

                % generate one point
                [seq, newPoints] = seq.generatePoints(1);

                % produce the output of the point (simulation)
                out = peaks(newPoints(1), newPoints(2));

                % give the output to the sequential design for processing
                seq = seq.updatePoints(newPoints, out);
            end




            % Also plot the surface so that it can be seen how points are distributed
            % according to the nonlinearity of the function.
            figure;
            range = [-5 : .2 : 5];
            grid = makeEvalGrid({range, range}); % generate a dense 2D grid
            out = peaks(grid(:,1), grid(:,2)); % evaluate this grid
            surfc(range, range, reshape(out, length(range), length(range))); % plot the surface
            [points, values] = seq.getAllPoints();
            hold on;
            plot3(points(:,1), points(:,2), values, 'ob', 'MarkerFaceColor','b');
            xlabel('x1'); ylabel('x2'); zlabel('out');
            % It can now clearly be seen that points are distributed much more densely
            % around the three hills near the center. These regions are also more
            % difficult to approximate than the flat regions near the borders, so this
            % is a sensible sample distribution. 
        end
        
        function [seq, point] = GenerateNewPoint(seq)
                % generate one point
                [seq, point] = seq.generatePoints(1);
        end
        
        function seq = UpdatePointEvaluation(seq,newPoint,value)
            seq = seq.updatePoints(newPoint,value);
        end
    end
    
end

